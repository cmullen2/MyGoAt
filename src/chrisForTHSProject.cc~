#include "chrisForTHSProject.h"
#include "TROOT.h"

chrisForTHSProject::chrisForTHSProject()
{ 
  gROOT->ProcessLine("#include <vector>");

  treePi0 =  new TTree("HSParticles","Event selection tree"); // Neutron pi0 final state tree   
  //treeProtonPi0 =  new TTree("ProtonPi0","Event selection tree"); // Proton pi0 final state tree   


  //Neutron Tree branches
  // treePi0->Branch("Particles.","vector<THSParticle>",&Particles);
  treePi0->Branch("Particles",&Particles);
  treePi0->Branch("fbeamHelicity",&fbeamHelicity);
  treePi0->Branch("ftaggedTime",&ftaggedTime);
  treePi0->Branch("feventNo",&feventNo);
  treePi0->Branch("fenergyBeam",&fenergyBeam);
  treePi0->Branch("fenergySum",&fenergySum);
  treePi0->Branch("fmultiplicity",&fmultiplicity);
  treePi0->Branch("fpidPhi",&fpidPhi);
  treePi0->Branch("fpidIndex",&fpidIndex);
//  treePi0->Branch("fpidRootinoPhi",&fpidRootinoPhi);
  treePi0->Branch("fchamber1Vec",&fchamber1Vec);
  treePi0->Branch("fchamber2Vec",&fchamber2Vec);
  treePi0->Branch("fedgeplane",&fedgePlane);
  treePi0->Branch("flinPol",&flinPol);
  
}

chrisForTHSProject::~chrisForTHSProject()
{

}

Bool_t	chrisForTHSProject::Init()
{
	cout << "Initialising physics analysis..." << endl;
	cout << "--------------------------------------------------" << endl << endl;



	std::string config = ReadConfig("Period-Macro");
	if( sscanf(config.c_str(),"%d\n", &period) == 1 ) usePeriodMacro = 1;

	target.SetXYZM(0.0,0.0,-65.0,1875.613);	//NEEDS CHANGING currently deuteron
//	target.SetXYZM(0.0,0.0,-65.0,938.272);	//NEEDS CHANGING only TEMP for a SIM

	//Following line may break due to GetNTagged not being defined yet, if so simply replace with a number and the while statement in main will correct it.
	fNin = (3+ (GetTagger()->GetNTagged()) ) ; //Estimate of Number of input particles(tagged+ball+rootinos etc.) Can and will calc this!(3+NTagged)
	fReadParticles=new vector<THSParticle*>;
	for(Int_t m=0; m<fNin; m++ ){
	  fReadParticles->push_back(new THSParticle());
	}

	if(!InitBackgroundCuts()) return kFALSE;
	if(!InitTargetMass()) return kFALSE;
	if(!InitTaggerChannelCuts()) return kFALSE;
	if(!InitTaggerScalers()) return kFALSE;
	cout << "--------------------------------------------------" << endl;
	return kTRUE;
}

Bool_t	chrisForTHSProject::Start()
{
    if(!IsGoATFile())
    {
        cout << "ERROR: Input File is not a GoAT file." << endl;
        return kFALSE;
    }
    SetAsPhysicsFile();

    TraverseValidEvents();

    return kTRUE;
}

void	chrisForTHSProject::ProcessEvent()
{

  if(usePeriodMacro == 1)
    {
      if(GetEventNumber() % period == 0)
	cout << "Events: " << GetEventNumber() << "  Events Accepted: " << nEventsWritten << endl;
    }

	// Unique Event ID
  std::string outFile = outputFile->GetName();
  std::size_t pos = outFile.find("_1");
  std::string filert = outFile.substr(pos);
  std::string fileNo =  filert.substr(2,4);
  Int_t tempEventno = GetEventNumber();
  std::string tevent = std::to_string(tempEventno);
  std::string eventName = fileNo + tevent;
  feventNo = std::stod(eventName);

  //Clearing the vectors.
  Particles.clear();


  

  //MWPC information
  targetPosition.SetXYZ(target.X(),target.Y(),target.Z());

  Int_t iii = 0;

  if (GetMWPCHitsChris()->GetNMWPCHitsChrisChamber1() != 0){
    fchamber1Vec.SetXYZ(GetMWPCHitsChris()->GetMWPCChamber1X(iii),GetMWPCHitsChris()->GetMWPCChamber1Y(iii),GetMWPCHitsChris()->GetMWPCChamber1Z(iii));
  }
  else{
    fchamber1Vec.SetXYZ(-1000,-1000,-1000);
  }

  if (GetMWPCHitsChris()->GetNMWPCHitsChrisChamber2() != 0){
    fchamber2Vec.SetXYZ(GetMWPCHitsChris()->GetMWPCChamber2X(iii),GetMWPCHitsChris()->GetMWPCChamber2Y(iii),GetMWPCHitsChris()->GetMWPCChamber2Z(iii));
  }
  else{
    fchamber2Vec.SetXYZ(-1000,-1000,-1000);
  }


  //PID information
  NPidhits = GetDetectorHits()->GetNPIDHits();
  
  // if (NPidhits>0){
  //   fpidIndex = GetDetectorHits()->GetPIDHits(0);    //The parameter in the Npidhits is the number of pid hits in the event while getPIDHits is the element number of a hit
  //   fpidPhi = PIDElemPhi[fpidIndex]; //here

  // } //closingpihits

  // else{  
    
  //   fpidPhi = -10;
  // }


  
  //Fill Beam Helicity (Two different determined states when helicity is 0 or 1, others are error codes) Chosen 1 and -1 for helicity from now on. 
  //Check for error codes here?? Need to decide if it is necessary? Should only be a small effect so come back to it once everything is working
  Bool_t Helicity = GetTrigger()->GetHelicity();
  if(Helicity == 1){
    fbeamHelicity = 1;
  }
  if(Helicity == 0){
    fbeamHelicity = -1;
  }

//Linear Polarisation Information
  if(GetLinpol()->GetPolarizationPlane()==0) fedgePlane = -1; // Para
  if(GetLinpol()->GetPolarizationPlane()==1){ fedgePlane = 1;} // Perp
  else{
	fedgePlane=0; //Moeller or other
}



  fNin= 3+ (GetTagger()->GetNTagged());
  Int_t countb4 = 0;
  Int_t countaft = 0;
  Int_t counter = 0;

  
  
//************************************************************************************************************************
//Methodology: Now using a rootino for proton so how  does this effect neutron will it be rootino or photon? photon right?
  if ( (GetPhotons()->GetNParticles()==3)){

    //PID info
    if (NPidhits==0){


      while(fNin>fReadParticles->size()){
	fReadParticles->push_back(new THSParticle());
      }

      
      for(Int_t j=0; j<GetPhotons()->GetNParticles(); j++){ 

	Particles.push_back(fReadParticles->at(j));
	fcbPhoton = GetPhotons()->Particle(j); //TLorentzVector
	Particles[j]->SetP4(fcbPhoton);
	Particles[j]->SetPDGcode(22);
	
	//	fballPhotons.SetP4(fcbPhoton); //THSParticle
	//	fballPhotons.SetPDGcode(22);
	//	Particles.push_back(&fballPhotons);


      } //Closing For NParticles 


      for(Int_t i=0; i<GetTagger()->GetNTagged() ;i++){
 	
	ftaggedTime = GetTagger()->GetTaggedTime(i);
	countb4 = countb4+1;

	
	if ( ftaggedTime > 40 && ftaggedTime <80 ) {

	  countaft=countaft+1;
	  counter = countb4 - countaft;
	  
	  Particles.push_back(fReadParticles->at(i+3-counter));
	  fmultiplicity = GetTrigger()->GetMultiplicity();
	  fenergySum =GetTrigger()->GetEnergySum();
	  fenergyBeam = GetTagger()->GetTaggedEnergy(i);
	  beam.SetXYZM(0.,0.,fenergyBeam,0.);  

	//Linear polarisation
          flinPol = GetLinpol()->GetPolarizationDegree(GetTagger()->GetTaggedChannel(i) );
	//Circular polarisation
	  Pcirc = ;	
	  
	  fglasgowTaggerPhoton.SetPxPyPzE(0,0,fenergyBeam, fenergyBeam);  //TLorentzVector
	  Particles[i+3-counter]->SetP4(fglasgowTaggerPhoton);
	  Particles[i+3-counter]->SetPDGcode(-22);
	  Particles[i+3-counter]->SetTime(ftaggedTime);
	  if (flinPol>0)  Particles[i+3-counter]->SetVertex(flinPol,0,Pcirc*fbeamHelicity);
	  if (flinPol<0)  Particles[i+3-counter]->SetVertex(0,flinPol,Pcirc*fbeamHelicity);
// Also what about Pcirc that Derek mentioned for Z component of setvertex(add to header flinpol)
// Need to figure out how to get para/perp to correspond to event in THSParticle.Add to THSParicle?


	  // ftaggPhotons.SetP4(fglasgowTaggerPhoton); //THSParticle
	  // ftaggPhotons.SetPDGcode(-22);
	  // ftaggPhotons.SetTime(ftaggedTime);
	  // Particles.push_back(&ftaggPhotons);
	  
	  
	} //closing if TaggedTime
	
      } //Closing for NTagged.

      
    } //closing NPIDHits if
    
  } //closing Number Protons ==3 
    
    //Do Proton channel here 

    //********************************************************************************************************************************
    
 
  if (GetPhotons()->GetNParticles()==2 && GetRootinos()->GetNParticles()==1){

    //PID info
    if (NPidhits>0){


      if (NPidhits>0){
        fpidIndex = GetDetectorHits()->GetPIDHits(0);    //The parameter in the Npidhits is the number of pid hits in the event while getPIDHits is the element number of a hit
        fpidPhi = PIDElemPhi[fpidIndex]; //here

      } //closingpihits

      else{  
    
        fpidPhi = -10;
      }
      

     while(fNin>fReadParticles->size()){
	fReadParticles->push_back(new THSParticle());
      }
         
      Particles.push_back(fReadParticles->at(0));
      frootino = GetRootinos()->Particle(0);
      Particles[0]->SetP4(frootino);
      Particles[0]->SetPDGcode(2212);
      // fcbRootino.SetP4(frootino);
      // fcbRootino.SetPDGcode(2212);
      // Particles.push_back(fcbRootino);




      for(Int_t k=0; k<GetPhotons()->GetNParticles(); k++){

	Particles.push_back(fReadParticles->at(k+1));
      	fcbPhoton = GetPhotons()->Particle(k); //TLorentzVector
	Particles[k+1]->SetP4(fcbPhoton);
	Particles[k+1]->SetPDGcode(22);
	
	// fballPhotons.SetP4(fcbPhoton); //THSParticle
	// fballPhotons.SetPDGcode(22);
	// Particles.push_back(&fballPhotons);
	
      
      } //Closing For NParticles 
        


      for(Int_t l=0; l<GetTagger()->GetNTagged() ;l++){
      
	ftaggedTime = GetTagger()->GetTaggedTime(l);

	countb4 = countb4 +1;


       	if ( ftaggedTime > 40 && ftaggedTime <80 ) {   //Atttempt to fix this by moving Particles.push_back(fReadParticles) b4 this;

	  countaft = countaft +1;
	  counter = countb4 - countaft;
	  Particles.push_back(fReadParticles->at(l+3-counter));
       	  fmultiplicity = GetTrigger()->GetMultiplicity();
    	  fenergySum =GetTrigger()->GetEnergySum();
    	  fenergyBeam = GetTagger()->GetTaggedEnergy(l);
    	  beam.SetXYZM(0.,0.,fenergyBeam,0.);


      	  fglasgowTaggerPhoton.SetPxPyPzE(0,0,fenergyBeam, fenergyBeam);  //TLorentzVector

          flinPol = GetLinpol()->GetPolarizationDegree(GetTagger()->GetTaggedChannel(l) );


	  
	  Particles[l+3-counter]->SetP4(fglasgowTaggerPhoton);
	  Particles[l+3-counter]->SetPDGcode(-22);
	  Particles[l+3-counter]->SetTime(ftaggedTime);
	  if (flinPol>0)  Particles[l+3-counter]->SetVertex(flinPol,0,0);
	  if (flinPol<0)  Particles[l+3-counter]->SetVertex(0,flinPol,0);
	  
	  // ftaggPhotons.SetP4(fglasgowTaggerPhoton); //THSParticle
    	  // ftaggPhotons.SetPDGcode(-22);
    	  // ftaggPhotons.SetTime(ftaggedTime);
    	  // Particles.push_back(&ftaggPhotons);
	  
	  
	  
	  
	} //closing if TaggedTime
	
      } //Closing for NTagged.
    
    
    } //closing NPIDHits if
  
  } //closing 2 photons and 1 rootino.  



  //*************************************************************************************************************************************

  

  //} //closing if 3 particles


  treePi0->Fill();
  
nEventsWritten++;

  
} //closing function


void	chrisForTHSProject::ProcessScalerRead()
{
	// Fill Tagger Scalers
	//FillScalers(GetTC_scaler_min(),GetTC_scaler_max(),TaggerAccScal);
}

Bool_t	chrisForTHSProject::Write()
{

  treePi0->Write(); 
  treePi0->Reset();

    return 0; //Added CAM 28/09/16

    // Write all GH1's and TObjects defined in this class
//    return GTreeManager::Write(); //Removed CAM 28/09/16
}


